#!/usr/bin/env es
# vim: et sw=3 sts=3

# does several things:

# - git update --init --recursive
# - makes any subdirectory with a
# - create symlinks from $HOME to here.
#   if here is inside $HOME, the links are relative.
# - generates an uninstall script, usually invoked by itself.

# install u  to uninstall
# install f  to install even if some files already exist
#            they will be backed up, uninstall will restore

# A list of operations to be attempted in order to install our stuff.
# They're defined immediately below. They take care of their own
# rollback-ing.
targets = (
   { ensure_directory .config }
   { link_file .config/herbstluftwm }
   { link_name .config/nvim ../.vim }
   { link_file .esrc }
   { link_file .gitconfig }
   { link_file .profile }
   { link_file .vim }
   { link_file .vimrc }
   { ensure_directory .vim-tmp }
   { ensure_directory .vim-undo }
   { link_file .Xresources }
   { link_file .xsessionrc }

   { ensure_directory bin }
   { ensure_directory src }
   { ensure_directory tmp }

   # handle this specially because .ssh permissions are important
   { ensure_directory .ssh { chmod go-rwx $HOME/.ssh } }
   { link_file .ssh/config }
)

# Link a particular filename from $HOME and append the complementary
# operation to the uninstaller script
fn link_file n {
   prepare_target $n {ln -s $linkpath/$n $HOME/$n}
}

# Make a filename (relative to $HOME) an arbitrary symbolic link
fn link_name n t {
   prepare_target $n {ln -s $t $HOME/$n}
}

# Ensure a name relative to $HOME is a directory. Can't be forced if
# it's not a directory; uninstalling would have to remove the dir
# again, which I don't like.
fn ensure_directory n f {
   echo \= $n
   if {[ -d $HOME/$n ]} {
      return
   } {[ -e $HOME/$n ]} {
      echo error: $HOME/$n exists and is not a directory
   } {
      mkdir -p $HOME/$n
      $f
   }
}

#####

catch @ {
   fn realpath p { readlink -f $p }
} {
   %pathsearch realpath
}

if {result $0 || result $HOME || ~ $HOME /} {
   echo Insufficient environment
   exit 1
}

uninstaller = $HOME/.edk.uninstall.es

uninst=
force=
relative=

backup_dir=

if {~ $1 u} {
   echo Uninstall
   uninst=y
}

if {~ $1 f} {
   echo Force install
   force=y
}

local (me=$0) installpath=`{dirname `{realpath $me}}

if {~ $installpath $HOME/*} {
   linkpath = <={~~ $installpath $HOME/*}
   relative=y
   echo 'Relative install:' $linkpath
} {
   linkpath = $installpath
   echo 'Absolute install:' $linkpath
}

#####

# Uninstall a previous installation, and possibly restore from backups
fn uninstall a {
   if {[ -f $uninstaller ]} {
      fork {. $uninstaller $a}
      rm $uninstaller
   }
}

# Roll back the installation in progress
fn rollback {
   uninstall
   if {! result $#backup_dir} {rmdir $backup_dir}
}

# If this is a relative installation, return enough '../' to get from
# the file named by $f to its containing directory
fn relpath f {
   if {result $relative} return
   local (t='') {
      while {~ $f ?*/?*} {
         f = (<={~~ f ?*/*})(3)
         t = $t ^ '../'
      }
      result $t
   }
}

# Return the path to the backup directory, creating it if necessary
fn backup_dir {
   if {result $#backup_dir} {
      backup_dir=`` \n {mktemp -d -p $HOME .edk.backup-XXXXXXXX}
   }
   result $backup_dir
}

# Uninstaller-y groundwork for creating a file
# move it out of the way if we're forcing, execute f, and then create an
# uninstall line
fn prepare_target n f {
   echo + $n
   local (backuppath=) {
      local (linkpath=(<={relpath $n})^$linkpath) {
         if {[ -f $HOME/$n ]} {
            if {! result $#force} {
               backuppath = <={backup_dir} ^ /$n
               mv $HOME/$n $backuppath
               $f
            } {
               echo error: $HOME/$n exists
               return 'file exists'
            }
         } {
            $f
         }
      }
      f = ()
      let (p=$HOME/$n) {
         if {result $#backuppath} {
            remove = {
               echo - $n
               rm -- $p
            }
         } {
            let (backuppath=$backuppath) remove = {
               echo \* $n
               rm -- $p
               mv -- $backuppath $p
            }
         }
         echo $remove >> $uninstaller
      }
   }
}

#####

uninstall

if {result $#uninst} {
   echo Updating git modules...
   fork {
      cd $installpath
      git submodule update --init --recursive --quiet
   } || {
      echo Not installing, git errored
      exit 1
   }

   echo Making things...
   fork {
      cd $installpath
      for (f = `` \n {find . -type f -name Makefile}) {
         fork {
            cd `` \n {dirname $f}
            make || exit 1
         } || exit 1
      }
   } || {
      echo Not installing, a Makefile errored
      exit 1
   }

   mkdir -p $HOME/.vim-tmp

   for (target=$targets) {
      local (r=<=$target) {
         if {! result $r} {
            echo error occurred, uninstalling!
            rollback
            echo failed to install: $r
            exit $r
         }
      }
   }

   if {! result $#backup_dir} {
      let (backup_dir=$backup_dir)
         echo {rm -rf -- $backup_dir} >> $uninstaller
      # This isn't necessary or used by any script, but I don't like the idea
      # that I might have a backup directory but lose its restoring script
      ln $uninstaller $backup_dir/uninstall
      echo 'Existing files were moved to' $backup_dir
   }
}

echo Done.
