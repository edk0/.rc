# vim: ft=es

EDITOR = vi
VISUAL = vi
PAGER = less

catch @ {
   fn realpath p { readlink -f $p }
} {
   %pathsearch realpath
}

# find .esrc and resolve symlinks. the location of .es is relative to the
# directory it is in, so if .esrc is a symlink, .es does not also need to be
# symlinked.
if {! result $0} {
   # inside a `, $0 is '%backquote'
   local (me=$0) ESRC_PATH=`{realpath $me}
} {
   # just assume we're .esrc
   ESRC_PATH=`{realpath .esrc}
}
ESRC_DIR=`{dirname $ESRC_PATH}

. $ESRC_DIR/.es/alias.es
. $ESRC_DIR/.es/cdpath.es
. $ESRC_DIR/.es/cd_history.es
. $ESRC_DIR/.es/session.es

fn map f { let (s=) { while {!%count <={s = <=%read}} {$f <={%split <={%flatten '' $ifs} $s}} } }
fn filter f { map @{ if {$f $* >/dev/null} {echo $*} } }

cdpath = . ~ ~/src

# set up our PATH. i want sourcing .esrc to be idempotent, so add things only
# if they're not already there. ~/bin should override $ESRC_DIR/bin.
if {! ~ $path $ESRC_DIR/bin} {
   path = $ESRC_DIR/bin $path
}
if {! ~ $path $home/bin && [ -d $home/bin ]} {
   path = $home/bin $path
}

# run a command even if a function by the same name exists
fn command name args { local (fn-$name=) {$name $args} }

alias ls   ls   --color\=auto
alias grep grep --color\=auto

alias l    ls -CF
alias ll   ls -CFA
alias hc   herbstclient
alias q    exit
alias tt   tee /dev/tty
alias up   ssh upload

# git is stupid
fn git cmd a {
   if {~ $cmd commit} {
      command git commit -v $a
   } {
      command git $cmd $a
   }
}

# these commands take commands as an argument; recursive-alias them to
# themselves so said argument gets expanded if it's an alias.
local (cmds = (
   command
   nohup
   stdbuf
   sudo
   time
)) for (cmd=$cmds) { aliasr $cmd $cmd }

# 'env a\=b c\=d command` should expand command as an alias.
%makealias env <={
   %alias_expands \
      @ x{~ $x -* *\=*} \
      0 \
      env
}

# mechanism for shells post-login to update their environments. new
# interactive shells will update_env, sourcing this file again if the copy in
# their environment is old.
# prompts can use %outdated_env to tell me i should run update_env.
# all this is a compromise between me wanting to avoid tediously sourcing
# .esrc myself, avoid sourcing it when unnecessary, and avoid magically
# breaking all my shells if i screw up
let (esrc_mtime=`{stat -c%Y $ESRC_PATH}) {
   fn %outdated_env {
      [ `{stat -c%Y $ESRC_PATH} -gt $esrc_mtime ]
   }
   fn update_env {
      if {%outdated_env} {
         . $ESRC_PATH
      }
   }
}

# the idea here is to run .es/session.es at the beginning of every
# interactive session
fn %prompt {
   fn %prompt
   %sessionrc
   if {! result $fn-%prompt} %prompt
}

true
